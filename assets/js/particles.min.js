// Create a canvas for the background animation
const canvas = document.createElement("canvas");
document.body.appendChild(canvas);
const ctx = canvas.getContext("2d");

// Set canvas to cover the whole screen
canvas.style.position = "fixed";
canvas.style.top = "0";
canvas.style.left = "0";
canvas.style.zIndex = "-1"; // Behind everything else
canvas.style.pointerEvents = "none";

// Resize the canvas to fit the screen
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener("resize", resizeCanvas);

// Number of particles and radius for circular arrangement
const numParticles = 100;
const radius = 200; // Radius of the circle
const particles = [];

// Particle class to represent each particle with a center shape
class Particle {
  constructor(x, y, size) {
    this.x = x; // X position of the center of the particle
    this.y = y; // Y position of the center of the particle
    this.size = size; // Size of the particle (can be for a square, triangle, etc.)
    this.vx = (Math.random() - 0.5) * 2; // Random X velocity for floating effect
    this.vy = (Math.random() - 0.5) * 2; // Random Y velocity for floating effect
  }

  draw() {
    // Draw the particle (square shape)
    ctx.beginPath();
    ctx.rect(
      this.x - this.size / 2,
      this.y - this.size / 2,
      this.size,
      this.size
    ); // Square shape
    ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
    ctx.fill();
    ctx.closePath();
  }

  move() {
    // Move the particle based on its velocity
    this.x += this.vx;
    this.y += this.vy;

    // Make particles wrap around the screen (like floating)
    if (this.x < 0) this.x = canvas.width;
    if (this.x > canvas.width) this.x = 0;
    if (this.y < 0) this.y = canvas.height;
    if (this.y > canvas.height) this.y = 0;
  }
}

// Create particles arranged in a circle
const centerX = canvas.width / 2; // Center of the circle
const centerY = canvas.height / 2; // Center of the circle
const angleStep = (2 * Math.PI) / numParticles; // Angle between each particle

for (let i = 0; i < numParticles; i++) {
  const angle = angleStep * i;
  const x = centerX + radius * Math.cos(angle); // X position on the circle
  const y = centerY + radius * Math.sin(angle); // Y position on the circle
  particles.push(new Particle(x, y, 10)); // Create a floating square (or any other shape)
}

// Function to draw lines (connections) between the particles based on distance threshold
function drawConnections() {
  const connectionDistance = 150; // The maximum distance at which particles will connect

  for (let i = 0; i < particles.length; i++) {
    for (let j = i + 1; j < particles.length; j++) {
      const dx = particles[i].x - particles[j].x;
      const dy = particles[i].y - particles[j].y;
      const distance = Math.sqrt(dx * dx + dy * dy);

      // Only draw a line if the particles are within the specified distance threshold
      if (distance < connectionDistance) {
        const alpha = 1 - distance / connectionDistance; // Fade out the lines as the distance increases
        ctx.beginPath();
        ctx.moveTo(particles[i].x, particles[i].y);
        ctx.lineTo(particles[j].x, particles[j].y);
        ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`; // Adjust line transparency based on distance
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.closePath();
      }
    }
  }
}

// Animation loop for particles and connections
function animateParticles() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw the connections between the particles
  drawConnections();

  // Move and draw each particle
  particles.forEach((particle) => {
    particle.move(); // Move the particle
    particle.draw(); // Draw the particle (square shape)
  });

  requestAnimationFrame(animateParticles);
}

animateParticles();
